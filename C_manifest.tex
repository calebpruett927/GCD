% chapters/C_manifest.tex
\chapter{Manifest Schema (JSON/YAML) \& Hash Policy}
\label{apx:manifest}

The manifest is the public fingerprint of an audited bundle. It enumerates artifacts, records hashes, and binds releases to weld IDs. This appendix provides a minimal schema (JSON and YAML), examples, and the hash policy for deterministic bundle IDs.

\section{Goals \& Scope}
\label{sec:manifest-goals}

\begin{itemize}[leftmargin=1.25em]
  \item \textbf{Deterministic identity.} Same inputs \(\Rightarrow\) same manifest hash.
  \item \textbf{Minimal fields.} Enough to verify artifacts and welds; no hidden state.
  \item \textbf{Portable text.} JSON and YAML encodings carry identical content.
\end{itemize}

\section{Canonical JSON Schema (concise)}
\label{sec:manifest-jsonschema}

\begin{lstlisting}[language=json,caption={JSON Schema (concise).},label={lst:manifest-schema}]
{
  "type": "object",
  "required": ["manifest_version", "build_date", "tz",
               "contract", "files", "welds", "root_hash"],
  "properties": {
    "manifest_version": { "type": "string", "pattern": "^1\\.[0-9]+$" },
    "build_date": { "type": "string", "pattern": "^[0-9]{4}-[0-9]{2}-[0-9]{2}$" },
    "tz": { "type": "string", "enum": ["America/Chicago"] },
    "contract": {
      "type": "object",
      "required": ["a","b","epsilon","p","alpha","face_policy"],
      "properties": {
        "a": {"type": "number"}, "b": {"type": "number"},
        "epsilon": {"type": "number"}, "p": {"type": "string"},
        "alpha": {"type": "number"},
        "face_policy": {"type": "string", "enum": ["pre_clip","post_clip+guard"]}
      }
    },
    "files": {
      "type": "array",
      "items": {
        "type": "object",
        "required": ["path","sha256","bytes"],
        "properties": {
          "path": {"type": "string"},
          "sha256": {"type": "string", "pattern": "^[a-f0-9]{64}$"},
          "bytes": {"type": "integer", "minimum": 0}
        }
      }
    },
    "welds": {
      "type": "array",
      "items": {
        "type": "object",
        "required": ["weld_id","notes"],
        "properties": {
          "weld_id": {"type": "string"},
          "notes": {"type": "string"}
        }
      }
    },
    "root_hash": { "type": "string", "pattern": "^[a-f0-9]{64}$" }
  },
  "additionalProperties": false
}
\end{lstlisting}

\section{Minimal JSON Manifest (example)}
\label{sec:manifest-json}

\begin{lstlisting}[language=json,caption={Example manifest (JSON).},label={lst:manifest-json}]
{
  "manifest_version": "1.0",
  "build_date": "2025-09-23",
  "tz": "America/Chicago",
  "contract": {
    "a": 0.0, "b": 1.0, "epsilon": 1e-8, "p": "secant", "alpha": 1.0,
    "face_policy": "pre_clip"
  },
  "files": [
    {"path": "main.pdf",
     "sha256": "9f3c1b0b2c2b0b6f4a0e8b7c3b29a1b7f88a5d51d1b3e4a0f1b2c3d4e5f6a7b8",
     "bytes": 1048576},
    {"path": "chapters/08_physics.tex",
     "sha256": "b6a1c9d2e3f47a0b19c2d3e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4",
     "bytes": 16384}
  ],
  "welds": [
    {"weld_id": "W-2025-09-23-book-01",
     "notes": "First edition: kernel finalized; captions standardized."}
  ],
  "root_hash": "7c4e1a9d2b3f5c6e7a8b9012c3d4e5f6a7b8c9d0e1f23456789abcdeffedcba0"
}
\end{lstlisting}

\section{Minimal YAML Manifest (example)}
\label{sec:manifest-yaml}

\begin{lstlisting}[caption={Example manifest (YAML).},label={lst:manifest-yaml}]
manifest_version: "1.0"
build_date: "2025-09-23"
tz: "America/Chicago"
contract:
  a: 0.0
  b: 1.0
  epsilon: 1e-8
  p: "secant"
  alpha: 1.0
  face_policy: "pre_clip"
files:
  - path: "main.pdf"
    sha256: "9f3c1b0b2c2b0b6f4a0e8b7c3b29a1b7f88a5d51d1b3e4a0f1b2c3d4e5f6a7b8"
    bytes: 1048576
  - path: "chapters/08_physics.tex"
    sha256: "b6a1c9d2e3f47a0b19c2d3e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4"
    bytes: 16384
welds:
  - weld_id: "W-2025-09-23-book-01"
    notes: "First edition: kernel finalized; captions standardized."
root_hash: "7c4e1a9d2b3f5c6e7a8b9012c3d4e5f6a7b8c9d0e1f23456789abcdeffedcba0"
\end{lstlisting}

\section{Hash Policy (deterministic root hash)}
\label{sec:manifest-hash}

\paragraph{File hash.} Each file’s \texttt{sha256} is the SHA-256 of its raw bytes. No re-encoding. Text files should already be normalized (UTF-8, LF) at source.

\paragraph{Bundle root hash (definition).} Sort \texttt{files} by \texttt{path} (bytewise ascending). For each entry \(i\), form the line:
\[
\texttt{path}_i \ \Vert\ \texttt{\textbackslash0}\ \Vert\ \texttt{sha256}_i \ \Vert\ \texttt{\textbackslash n}.
\]
Concatenate all lines to a single byte string \(B\). The bundle hash is
\[
\texttt{root\_hash} \;=\; \mathrm{SHA256}(B).
\]
This makes the root hash independent of platform path separators and whitespace.

\paragraph{What to include.} Include only files that render the public artifact (text, figures, local data). Exclude transient products (aux, log, cache). The manifest itself is not part of the \texttt{root\_hash} input; it records the result.

\section{Validation Checklist (quick)}
\label{sec:manifest-checklist}

\begin{itemize}[leftmargin=1.25em]
  \item Build date uses absolute format \texttt{YYYY-MM-DD} in America/Chicago.
  \item Contract keys and face policy match captions.
  \item Every public file has a \texttt{sha256} and byte count.
  \item Weld IDs listed match those used in captions.
  \item \texttt{root\_hash} recomputes from \texttt{files} exactly.
\end{itemize}

\medskip
With this schema and hash policy, any reader can confirm that a release is the same one you audited and captioned—byte for byte.
